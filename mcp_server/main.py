# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:47:25+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    APIKeyCookie,
    APIKeyHeader,
    APIKeyQuery,
    BaseSecurity,
)
from fastapi import Path, Query, UploadFile

from models import (
    AuthinfoGetResponse,
    Blob,
    BlobsGetResponse,
    CodeHex,
    Event,
    EventsGetResponse,
    EventTopicAction,
    EventTopicResourceType,
    IdReadOnly,
    IsOnline,
    Item,
    ItemList,
    ItemProtocol,
    ItemsGetResponse,
    ItemType,
    ItemUpdate,
    Key,
    KeysGetResponse,
    KeyValuePair,
    KeyValuePairUpdate,
    KvpairsGetResponse,
    Label,
    ListOfItemIds,
    Location,
    LocationRule,
    LocationrulesGetResponse,
    LocationRuleType,
    LocationRuleUpdate,
    LocationsGetResponse,
    MoveCount,
    Name,
    Presence,
    PresencesGetResponse,
    Proximity,
    RequestCounter,
    ResponseDefaultResource,
    ResponseListResource,
    RuleEnabled,
    SerialNumber,
    Service,
    ServicesGetResponse,
    SetsItemlistsGetResponse,
    SetsSpotlistsGetResponse,
    SpotGet,
    SpotList,
    SpotSet,
    SpotSetCreate,
    SpotSetUpdate,
    SpotsGetResponse,
    SpotUpdate,
    Subscription,
    SubscriptionsGetResponse,
    SubscriptionsIdEventsGetResponse,
    Technology,
    TimeCreated,
    TimeExpire,
    TimeMoved,
    TimeUpdated,
    User,
    UsersGetResponse,
)

app = MCPProxy(
    contact={
        'email': 'support@intellifi.nl',
        'name': 'Support',
        'url': 'https://intellifi.zendesk.com',
    },
    description="This document describes the [Intellifi Brain](https://intellifi.zendesk.com/hc/en-us/categories/360000685454)\nWeb API specification using the [OpenAPI specification](https://github.com/OAI/OpenAPI-Specification).\n\nThe Brain Web API is a RESTful API that allows you to interact with the\n[Intellifi devices](https://intellifi.zendesk.com/hc/en-us/categories/360000685434) and\nservices in a powerful and simple way. Our end-to-end solution allows you to\nlocalize your items/assets based on technologies such as RFID and Bluetooth.\n\n# Try it out!\n\nThe API can be tried out and tested using the ['api-doc/tryitout' endpoint on this site](./tryitout/).\nThis UI allows anyone to visualize and interact with the API’s resources without having any of the implementation logic in place.\nIt’s automatically generated from this Specification, with the visual documentation making it easy for back end implementation and client side consumption.\n\n# Authentication\n\nApplications are required to provide some form of authentication to the API\nfor every secured endpoint. The Brain offers two forms of authentication.\n\n- API key (Via an HTTP request header or URL parameter)\n- Session cookie\n\n<!-- ReDoc-Inject: <security-definitions> -->\n\n# See also\n\n- About Intellifi and what we do: [intellifi.nl](https://intellifi.nl)\n- Technical and background information: [intellifi.zendesk.com](https://intellifi.zendesk.com)\n",
    license={'name': 'MIT', 'url': './LICENSE'},
    title='Brain Web API',
    version='2.23.2+0.gfbc3926.dirty',
    servers=[
        {
            'description': 'Cloud hosted Brain API endpoint.',
            'url': '{protocol}://{customer}.intellifi.{tld}/api',
            'variables': {
                'customer': {
                    'default': 'brain',
                    'description': 'Customer sub-domain assigned by Intellifi',
                },
                'protocol': {'default': 'https', 'enum': ['https', 'http']},
                'tld': {'default': 'cloud', 'enum': ['nl', 'cloud']},
            },
        }
    ],
)


@app.get(
    '/authinfo',
    tags=['user_authentication', 'user_profile_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_authinfo():
    """
    Authentication information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/blobs',
    tags=['blob_storage_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_blobs(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    hash: Optional[str] = None,
    blob_key: Optional[str] = None,
    content_type: Optional[str] = None,
    filename: Optional[str] = None,
    time_last_accessed: Optional[str] = None,
):
    """
    Get all binary large objects (blob)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/blobs',
    tags=['blob_storage_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_blob(body: Blob):
    """
    Create binary large object (blob) metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/blobs/{id}',
    tags=['blob_storage_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_blob(id: str):
    """
    Delete binary large object (blob)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/blobs/{id}',
    tags=['blob_storage_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_blob_metadata_by_id(id: str):
    """
    Get binary large object (blob)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/blobs/{id}/download/{filename}',
    tags=['blob_storage_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_blob_by_id(id: str, filename: str = ...):
    """
    Download a binary large object (blob)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/blobs/{id}/upload',
    tags=['blob_storage_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def upload_blob_by_id(id: str, file: UploadFile = ...):
    """
    Create binary large object (blob)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events',
    tags=['event_crud_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_events(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    topic_resource_type: Optional[EventTopicResourceType] = Query(
        None, alias='topic.resource_type'
    ),
    topic_action: Optional[EventTopicAction] = Query(None, alias='topic.action'),
    topic_resource: Optional[IdReadOnly] = Query(None, alias='topic.resource'),
    time_event: Optional[TimeExpire] = None,
    time_expire: Optional[TimeExpire] = None,
):
    """
    Get all events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events/{id}',
    tags=['event_crud_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_event_by_id(id: str):
    """
    Get event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_items(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    after_code: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    before_code: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    from_code: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    until_code: Optional[str] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    code_hex: Optional[CodeHex] = None,
    is_present: Optional[bool] = None,
    label: Optional[Label] = None,
    location: Optional[IdReadOnly] = None,
    metadata: Optional[str] = None,
    move_count: Optional[MoveCount] = None,
    protocol: Optional[ItemProtocol] = None,
    sets: Optional[IdReadOnly] = None,
    technology: Optional[Technology] = None,
    text: Optional[str] = None,
    time_last_present: Optional[str] = None,
    time_moved: Optional[TimeMoved] = None,
    type: Optional[ItemType] = None,
):
    """
    Get all items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/items',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_item(body: Item):
    """
    Create item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/items/{id}',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_item(id: str):
    """
    Delete item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items/{id}',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_item_by_id(id: str):
    """
    Get item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/items/{id}',
    tags=['inventory_item_management', 'event_crud_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_item(id: str, body: ItemUpdate = ...):
    """
    Update existing item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keys',
    description=""" Can only be used by an **administrative** user. """,
    tags=['key_value_storage_management', 'cryptographic_key_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def get_keys(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    secret: Optional[str] = None,
    label: Optional[str] = None,
    is_read_only: Optional[bool] = None,
):
    """
    Get all keys
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/keys',
    description=""" Can only be used by an **administrative** user. """,
    tags=['cryptographic_key_management', 'key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def add_key(body: Key):
    """
    Create key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/keys/{id}',
    description=""" Can only be used by an **administrative** user. """,
    tags=['cryptographic_key_management', 'key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def delete_key(id: str):
    """
    Delete key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keys/{id}',
    description=""" Can only be used by an **administrative** user. """,
    tags=['cryptographic_key_management', 'key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def get_key_by_id(id: str):
    """
    Get key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/keys/{id}',
    description=""" Can only be used by an **administrative** user. """,
    tags=['cryptographic_key_management', 'key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def update_key(id: str, body: Key = ...):
    """
    Update existing key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/kvpairs',
    tags=['key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_kv_pairs(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    kv_key: Optional[str] = None,
):
    """
    Get all key-value pairs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kvpairs',
    tags=['key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_kv_pairs(body: KeyValuePair):
    """
    Create key-value pair
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/kvpairs/{id}',
    tags=['key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_kv_pair(id: str):
    """
    Delete key-value pair
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/kvpairs/{id}',
    tags=['key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_kv_pairs_by_id(id: str):
    """
    Get key-value pair
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/kvpairs/{id}',
    tags=['key_value_storage_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_kv_pair(id: str, body: KeyValuePairUpdate = ...):
    """
    Update existing Key-value pair
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locationrules',
    tags=['location_rule_operations', 'geo_location_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_location_rules(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    label: Optional[Label] = None,
    type: Optional[LocationRuleType] = None,
    enabled: Optional[RuleEnabled] = None,
):
    """
    Get all location rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locationrules',
    tags=['location_rule_operations', 'geo_location_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_location_rule(body: LocationRuleUpdate):
    """
    Create location rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/locationrules/{id}',
    tags=['location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_location_rule(id: str):
    """
    Delete location rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locationrules/{id}',
    tags=['location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_location_rule_by_id(id: str):
    """
    Get location rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/locationrules/{id}',
    tags=['location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_location_rule(id: str, body: LocationRuleUpdate = ...):
    """
    Update existing location rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations',
    tags=['geo_location_management', 'location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_locations(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    label: Optional[Label] = None,
    metadata: Optional[str] = None,
    text: Optional[str] = None,
):
    """
    Get all locations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/locations',
    tags=['geo_location_management', 'location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_location(body: Location):
    """
    Create location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/locations/{id}',
    tags=['geo_location_management', 'location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_location(id: str):
    """
    Delete location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/{id}',
    tags=['geo_location_management', 'location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_location_by_id(id: str):
    """
    Get location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/locations/{id}',
    tags=['geo_location_management', 'location_rule_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_location(id: str, body: Location = ...):
    """
    Update existing location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/presences',
    tags=['presence_information_retrieval'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_presences(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    item: Optional[IdReadOnly] = None,
    location: Optional[IdReadOnly] = None,
    proximity: Optional[Proximity] = None,
    technology: Optional[Technology] = None,
):
    """
    Get all presences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/presences/{id}',
    tags=['presence_information_retrieval'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_presence_by_id(id: str):
    """
    Get presence
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/services',
    tags=['service_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_services(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    name: Optional[Name] = None,
):
    """
    Get all services
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/services/{id}',
    tags=['service_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_service_by_id(id: str):
    """
    Get service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/services/{id}',
    tags=['service_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_service(id: str, body: Service = ...):
    """
    Update existing service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sets/itemlists',
    tags=['item_list_operations', 'inventory_item_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_item_lists(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    label: Optional[Label] = None,
    metadata: Optional[str] = None,
    text: Optional[str] = None,
    total: Optional[int] = None,
    sha1: Optional[str] = None,
):
    """
    Get all item lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sets/itemlists',
    tags=['item_list_operations', 'inventory_item_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_item_list(body: ItemList):
    """
    Create item list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sets/itemlists/{id}',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_item_set(id: str):
    """
    Delete item list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sets/itemlists/{id}',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_item_list_by_id(id: str):
    """
    Get item list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/sets/itemlists/{id}',
    tags=['inventory_item_management', 'item_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_item_list(id: str, body: ItemList = ...):
    """
    Update existing item list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sets/itemlists/{id}/ids',
    tags=['item_list_operations', 'inventory_item_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_item_list_ids_by_id(id: str):
    """
    Get item ids for this list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sets/itemlists/{id}/ids',
    tags=['item_list_operations', 'inventory_item_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_item_ids_list(id: str, body: ListOfItemIds = ...):
    """
    Add items to an existing list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sets/itemlists/{id}/ids/{itemId}',
    tags=['item_list_operations', 'inventory_item_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_item_id_from_item_list(id: str, item_id: str = Path(..., alias='itemId')):
    """
    Delete item from list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sets/spotlists',
    tags=['spot_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spot_lists(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    label: Optional[Label] = None,
    metadata: Optional[str] = None,
    text: Optional[str] = None,
    total: Optional[int] = None,
):
    """
    Get all spot lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sets/spotlists',
    tags=['item_list_operations', 'spot_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_spot_list(body: ItemList):
    """
    Create spot list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sets/spotlists/{id}',
    tags=['spot_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_spot_list(id: str):
    """
    Delete spot list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sets/spotlists/{id}',
    tags=['spot_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spot_list_by_id(id: str):
    """
    Info for a specific spot list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/sets/spotlists/{id}',
    tags=['spot_list_operations', 'item_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_spot_list(id: str, body: SpotList = ...):
    """
    Update existing spot list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sets/spotlists/{id}/ids',
    tags=['spot_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spot_list_ids_by_id(id: str):
    """
    Get spot ids for this list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sets/spotlists/{id}/ids',
    tags=['item_list_operations', 'spot_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_item_ids_spot_list(id: str, body: ListOfItemIds = ...):
    """
    Add spots to an existing list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sets/spotlists/{id}/ids/{itemId}',
    tags=['spot_list_operations', 'item_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_item_id_from_spot_list(id: str, item_id: str = Path(..., alias='itemId')):
    """
    Delete spot from list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/spots',
    tags=['spot_list_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spots(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    is_online: Optional[IsOnline] = None,
    request_counter: Optional[RequestCounter] = None,
    serial_number: Optional[SerialNumber] = None,
):
    """
    Get all spots
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/spots/{id}',
    tags=['spot_entity_management', 'spot_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spot_by_id(id: str):
    """
    Get spot
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/spots/{id}',
    tags=['spot_entity_management', 'spot_list_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_spot(id: str, body: SpotUpdate = ...):
    """
    Update existing spot
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/spots/{id}/sets',
    tags=['spot_set_operations', 'spotset_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spot_sets_by_id(id: str):
    """
    Get spotsets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/spots/{id}/sets',
    tags=['spot_set_operations', 'spotset_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_spot_set(id: str, body: SpotSetCreate = ...):
    """
    Create spotset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/spots/{id}/sets/{setId}',
    tags=['spot_set_operations', 'spotset_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spot_set_by_id(id: str, set_id: str = Path(..., alias='setId')):
    """
    Get spotset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/spots/{id}/sets/{setId}',
    tags=['spotset_management', 'spot_set_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_spot_set(
    id: str, set_id: str = Path(..., alias='setId'), body: SpotSetUpdate = ...
):
    """
    Update existing spotset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/spotsets',
    tags=['spot_set_operations', 'spotset_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spotsets():
    """
    Get spotsets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/spotsets',
    tags=['spot_set_operations', 'spotset_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def post_spotsets(body: SpotSetCreate):
    """
    Create spotset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/spotsets/{id}',
    tags=['spot_set_operations', 'spotset_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_spotsets__id(id: str):
    """
    Get spotset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/spotsets/{id}',
    tags=['spotset_management', 'spot_set_operations', 'spot_entity_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def put_spotsets__id(id: str, body: SpotSetUpdate = ...):
    """
    Update existing spotset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions',
    tags=['subscription_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_subscriptions(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    topic_filter: Optional[str] = None,
    description: Optional[str] = None,
    database_hold_time_h: Optional[int] = None,
    populate_events: Optional[bool] = None,
    verify_target_certificate: Optional[bool] = None,
):
    """
    Get all subscriptions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions',
    tags=['subscription_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def add_subscription(body: Subscription):
    """
    Create subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/subscriptions/{id}',
    tags=['subscription_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def delete_subscription(id: str):
    """
    Delete subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{id}',
    tags=['subscription_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_subscription_by_id(id: str):
    """
    Get subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/subscriptions/{id}',
    tags=['subscription_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def update_subscription(id: str, body: Subscription = ...):
    """
    Update existing subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{id}/events',
    tags=['subscription_operations', 'event_crud_operations'],
    security=[
        APIKeyCookie(name="brain.sid"),
        APIKeyHeader(name="X-Api-Key"),
        APIKeyQuery(name="key"),
    ],
)
def get_events_for_subscription_by_id(
    id: Union[str, Optional[IdReadOnly], Optional[IdReadOnly], Optional[IdReadOnly]],
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    time_created: Optional[TimeCreated] = None,
    topic_resource_type: Optional[EventTopicResourceType] = Query(
        None, alias='topic.resource_type'
    ),
    topic_action: Optional[EventTopicAction] = Query(None, alias='topic.action'),
    topic_resource: Optional[IdReadOnly] = Query(None, alias='topic.resource'),
    time_event: Optional[TimeExpire] = None,
    time_expire: Optional[TimeExpire] = None,
):
    """
    Get subscription events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    description=""" Can only be used by an **administrative** user. """,
    tags=['user_authentication', 'user_profile_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def get_users(
    after: Optional[datetime] = None,
    after_id: Optional[str] = None,
    before: Optional[str] = None,
    before_id: Optional[str] = None,
    from_: Optional[str] = Query(None, alias='from'),
    from_id: Optional[str] = None,
    id_only: Optional[bool] = False,
    limit: Optional[int] = 100,
    populate: Optional[str] = None,
    results_only: Optional[bool] = False,
    select: Optional[str] = None,
    sort: Optional[str] = '-id',
    until: Optional[str] = None,
    until_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    id: Optional[IdReadOnly] = None,
    time_created: Optional[TimeCreated] = None,
    time_updated: Optional[TimeUpdated] = None,
    email: Optional[str] = None,
    first_name: Optional[str] = None,
    last_name: Optional[str] = None,
    is_admin: Optional[bool] = None,
    is_locked: Optional[bool] = None,
):
    """
    Get all users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users',
    description=""" Can only be used by an **administrative** user. """,
    tags=['user_profile_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def add_user(body: User):
    """
    Create user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/users/{id}',
    description=""" Can only be used by an **administrative** user. """,
    tags=['user_profile_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def delete_user(id: str):
    """
    Delete user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{id}',
    description=""" Can only be used by an **administrative** user. """,
    tags=['user_authentication', 'user_profile_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def get_user_by_id(id: str):
    """
    Get user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/users/{id}',
    description=""" Can only be used by an **administrative** user. """,
    tags=['user_profile_management'],
    security=[
        APIKeyCookie(name="brain.sid"),
    ],
)
def update_user(id: str, body: User = ...):
    """
    Update existing user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
